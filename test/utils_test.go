// auto-generated by Cursor
package main

import (
	"testing"

	"github.com/daniel0321forever/terriyaki-go/internal/utils"
)

// TestHashPassword tests the password hashing function
func TestHashPassword(t *testing.T) {
	password := "testpassword123"

	hashedPassword, err := utils.HashPassword(password)
	if err != nil {
		t.Fatalf("HashPassword() returned an error: %v", err)
	}

	// Check that the hashed password is not empty
	if hashedPassword == "" {
		t.Error("HashPassword() returned an empty string")
	}

	// Check that the hashed password is different from the original
	if hashedPassword == password {
		t.Error("HashPassword() returned the same string as input")
	}

	// Check that the hashed password is longer than the original (bcrypt hashes are longer)
	if len(hashedPassword) <= len(password) {
		t.Error("HashPassword() returned a hash that is not longer than the original password")
	}
}

// TestVerifyPassword tests the password verification function
func TestVerifyPassword(t *testing.T) {
	password := "testpassword123"

	// First, hash the password
	hashedPassword, err := utils.HashPassword(password)
	if err != nil {
		t.Fatalf("HashPassword() returned an error: %v", err)
	}

	// Test correct password
	if !utils.VerifyPassword(password, hashedPassword) {
		t.Error("VerifyPassword() returned false for correct password")
	}

	// Test incorrect password
	if utils.VerifyPassword("wrongpassword", hashedPassword) {
		t.Error("VerifyPassword() returned true for incorrect password")
	}

	// Test empty password
	if utils.VerifyPassword("", hashedPassword) {
		t.Error("VerifyPassword() returned true for empty password")
	}
}

// TestHashPasswordDifferentResults tests that hashing the same password twice produces different hashes
// (due to salt in bcrypt, each hash should be unique)
func TestHashPasswordDifferentResults(t *testing.T) {
	password := "testpassword123"

	hash1, err1 := utils.HashPassword(password)
	if err1 != nil {
		t.Fatalf("HashPassword() first call returned an error: %v", err1)
	}

	hash2, err2 := utils.HashPassword(password)
	if err2 != nil {
		t.Fatalf("HashPassword() second call returned an error: %v", err2)
	}

	// Both hashes should be different (bcrypt uses random salt)
	if hash1 == hash2 {
		t.Error("HashPassword() returned the same hash for the same password (should be different due to salt)")
	}

	// But both should verify correctly
	if !utils.VerifyPassword(password, hash1) {
		t.Error("First hash does not verify correctly")
	}

	if !utils.VerifyPassword(password, hash2) {
		t.Error("Second hash does not verify correctly")
	}
}

// Example of a table-driven test (a common Go testing pattern)
func TestVerifyPasswordTableDriven(t *testing.T) {
	password := "testpassword123"
	hashedPassword, err := utils.HashPassword(password)
	if err != nil {
		t.Fatalf("HashPassword() returned an error: %v", err)
	}

	// Define test cases
	tests := []struct {
		name           string
		password       string
		hashedPassword string
		expected       bool
	}{
		{
			name:           "correct password",
			password:       password,
			hashedPassword: hashedPassword,
			expected:       true,
		},
		{
			name:           "incorrect password",
			password:       "wrongpassword",
			hashedPassword: hashedPassword,
			expected:       false,
		},
		{
			name:           "empty password",
			password:       "",
			hashedPassword: hashedPassword,
			expected:       false,
		},
		{
			name:           "different case password",
			password:       "TESTPASSWORD123",
			hashedPassword: hashedPassword,
			expected:       false,
		},
	}

	// Run each test case
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := utils.VerifyPassword(tt.password, tt.hashedPassword)
			if result != tt.expected {
				t.Errorf("VerifyPassword() = %v, expected %v", result, tt.expected)
			}
		})
	}
}
